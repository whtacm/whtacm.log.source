---
title: 自定义View系列：简易九宫格手势锁控件
tags:
  - Java
  - Android
  - Android Studio
  - jitpack.io
categories:		
  - Android
 
date: 2017-01-04 22:36:32
---

>前言

项目里想添加一个九宫格手势锁的控件，在增加便捷性的同时来增加安全性，虽然是重复造轮子，但是本着自我娱乐的精神就手撸了一个简易九宫格手势锁的自定义view控件。


<!--- more --->
<br/>

# Demo 演示
<br/>
该控件实现的功能比较简单，一个九宫格手势解锁控件，你可以通过控件的几个属性来对控件的 UI 和功能进行控制：

- 九宫格圆圈的颜色和宽度 （`mLockCircleStrokeColor`/ `mLockCircleStrokeWidth`）
- 手势路径上小圆点的颜色 （`mLockPointStrokeColor`）
- 手势路径的颜色以及路径的宽 （`mLockPathStrokeColor`/ `mLockPathStrokeWidth`）
- 定义锁的最小和最大长度 （`mMinLockLength`/ `mMaxLockLength`）
- 锁是否可重复（手势划过的圆圈是否可重复）（`mRepeatAllowed`）
- 是否显示锁（手势划过的）路径 （`mShowPath`）
- 解（绘制）锁成功或失败时的小圆点和路径的颜色 （`mSuccessColor`/ `mErrorColor`）

下面是简单演示的动图：

![image](http://ofdub8np7.bkt.clouddn.com/2017/01/04/screenshot.gif)

<br/>
# 实现
<br/>

<br/>
## attr
<br/>

首先，定义下九宫格手势锁控件的相关属性，大概就下面几个，参照之前的说明，很容易理解。

```
  <declare-styleable name="com.robin.gesturelockview">
        <attr name="mMinLockLength" format="integer" />
        <attr name="mMaxLockLength" format="integer" />
        <attr name="mRepeatAllowed" format="boolean" />
        <attr name="mShowPath" format="boolean" />
        <attr name="mLockCircleStrokeWidth" format="dimension" />
        <attr name="mLockCircleStrokeColor" format="color" />
        <attr name="mLockPointStrokeColor" format="color" />
        <attr name="mLockPathStrokeColor" format="color" />
        <attr name="mLockPathStrokeWidth" format="dimension" />
        <attr name="mErrorColor" format="color" />
        <attr name="mSuccessColor" format="color" />
    </declare-styleable>
```

<br/>
## 绘制
<br/>
OK，进入正题。首先读取相关的属性，这个比较简单，跳过，主要说一下，就是默认的参数情况是：
- 最小最长锁长度是4
- 不允许重复锁
- 不显示手势路径
- 九宫格圆圈宽度是4px
- 手势路径宽度是4px
- 解（绘制）锁成功颜色是蓝色，失败则是红色
- 其他情况颜色均为黑色

那么首先，我们要读取自定义view的长宽数值，然后来初始化我们的画笔了,主要就是四个画笔，一个来绘制九宫格圆圈的 `mLockCirclePaint`，并且需要一个 `mLockInnerCirclePaint` 来配合绘制空心圆圈，`mLockPointPaint` 负责绘制手势路径上的小圆点，`mLockPathPaint` 则负责绘制手势路径。

```
		if (mWidth == 0) {
            mWidth = getWidth();
            mHeight = getHeight();
        }

        /**
         *
         */
        mLockInnerCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mLockInnerCirclePaint.setColor(Color.WHITE);

        mLockCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mLockCirclePaint.setColor(mLockCircleStrokeColor);

        mLockPointPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mLockPointPaint.setColor(mLockPointStrokeColor);

        mLockPathPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mLockPathPaint.setColor(mLockPathStrokeColor);
        mLockPathPaint.setStrokeWidth(mLockPathStrokeWidth);

        if (status == Status.FAIL) {
            mLockPointPaint.setColor(mErrorColor);
            mLockPathPaint.setColor(mErrorColor);
        }
        if (status == Status.SUCCESS) {
            mLockPointPaint.setColor(mSuccessColor);
            mLockPathPaint.setColor(mSuccessColor);
        }
```

这里，简单了定义几个绘制的状态，分为四个，看名字也非常容易理解，即初始阶段、解（绘制）锁中、成功和失败。通过状态值来改变相关画笔的颜色值。

```
 	enum Status {
        SUCCESS,
        FAIL,
        ORIGIN,
        LOCKING
    }
```

第一步，绘制九宫格空心圆圈，首先根据自定义 View 的宽度来计算空心圆圈的半径 mCirclrRadius，然后找左上角第一个空心圆圈距离自定义 View 的 marginLeft 和 marginTop 值，然后计算下空心圆圈之间的距离 marginBetweenCircles。 接下来，定位左上角第一个空心圆圈的圆点位置 （mStartCx， mStartCy），很好理解吧，marginLeft 和 marginTop 分别加上半径。根据左上角的圆圈的圆心为相对坐标点 （cx, cy），分别找个 9 个空心圆圈的圆心位置并绘制。


```
		mCirclrRadius = mWidth / 12;
        marginLeft = (mWidth - mCirclrRadius * 6) / 3;
        marginTop = (mHeight - mCirclrRadius * 6 - marginLeft) / 2;
        marginBetweenCircles = marginLeft / 2;

        mStartCx = marginLeft + mCirclrRadius;
        mStartCy = marginTop + mCirclrRadius;

        for (int i = 0; i < 9; i++) {
            int cx = mStartCx + (mCirclrRadius * 2 + marginBetweenCircles) * (i % 3);
            int cy = mStartCy + (mCirclrRadius * 2 + marginBetweenCircles) * (i / 3);
            canvas.drawCircle(cx, cy, mCirclrRadius, mLockCirclePaint);
            canvas.drawCircle(cx, cy, mCirclrRadius - mLockCircleStrokeWidth, mLockInnerCirclePaint);
        }
```

绘制完之后，我们来绘制手势划过九宫格空心圆圈时的小圆点和手势路径，


```
		if (mShowPath) {
            int lastcx = mStartCx;
            int lastcy = mStartCy;
            //
            for (int i = 0; i < mLockList.size(); i++) {
                int idx = mLockList.get(i);
                int cx = mStartCx + (mCirclrRadius * 2 + marginBetweenCircles) * (idx % 3);
                int cy = mStartCy + (mCirclrRadius * 2 + marginBetweenCircles) * (idx / 3);
                if (i > 0) {
                    canvas.drawLine(lastcx, lastcy, cx, cy, mLockPathPaint);
                }
                lastcx = cx;
                lastcy = cy;
            }

            //
            for (Integer idx : mLockList) {
                int cx = mStartCx + (mCirclrRadius * 2 + marginBetweenCircles) * (idx % 3);
                int cy = mStartCy + (mCirclrRadius * 2 + marginBetweenCircles) * (idx / 3);
                canvas.drawCircle(cx, cy, mCirclrRadius / 3, mLockPointPaint);
            }
        }

```

<br/>
## 事件
<br/>
<br/>
## 使用
<br/>
<br/>
# JitPack
<br/>

